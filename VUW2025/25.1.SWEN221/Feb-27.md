# Java Recap

The reciever is the thing before the dot 

```thingBeforeDot.java
myThing.get();
```

`List.of()` Is an unmodifiable collection, and has no object allocation.

## Private, Final, Or both

```myFirstClass.java
class Person{
    int age;
    age = 0;
}
bob.age = 34;

class Person{
    private int age;
    age = 0;
}
bob.age = 34; // does not compile.
//Only code inside the class Person has permission to see/update the age field.

class Person{
    final int age;
}
bob.age = 34;
//No code has permission to update the age field.

class Person{
    private final int age;
}
bob.age = 34;
//Only code inside the class Person has permission to see the age field.
//No code has permission to update the age field.

System.out.println(bob)//Prints examples.Person@52cc8049 Horrible!!
assert List.of(bob).contains(bob):"OK";
assert List.of(new Person("Bob",27)).contains(bob):"Fails!!"; // Not the same object.

public record Person(String name, int age){
    public String greet(String other){ return "Hi "+other+" I'm "+this.name; }
}

// Now we do records.

Person bob = new Person("Bob",27); //We instantiate an object of type Person

System.out.println(bob); //Prints Person[name=Bob, age=27]
assert List.of(new Person("Bob",27)).contains(bob):"OK NOW!";
```

## Records

```thisConstructor.java
// Multiple constructors

record Person(String name, String surname, int age, List<Person> friends){
    Person(String name, String surname, int age){
        this(name, surname, age, new ArrayList<Person>()); //the ‘this-constructor’
    } //Can define more constructors, for example for default field values

    @Override
    public String toString(){ return "{"+name+" "+surname+", "+age+"}"; }
}

record Car(String plate, List<Person> passengers){}

public static void main(String[] a) {
    var bob = new Person("Bob","Anslow",25);
    var alice= new Person("Alice","Pearce",26);

    bob.friends().add(alice);
    alice.friends().add(bob);

    Car nissan= new Car("HelloWorld", List.of(bob,alice));
    System.out.println(nissan);
}
```

```assertion.java
record Person(String name, String surname, int age, List<Person> friends){
    Person{ //Compact constructor, useful to enforce properties (invariants)
        assert !name.isEmpty(); //Check and fail
        if(surname.isEmpty()){ surname = "Unknown"; } //Check and fix

    }
}
```

```error.java
(1) assert !name.isEmpty();
(2) if (name.isEmpty()){ throw new IllegalArgumentException(); }
// Think about throwing errors
```

### Easy modeling

Records avoid most boilerplate code when using classes that just group together some fields.

Records play very well with interfaces with default methods, since the autogenerated getters can autoimplement interface methods.

## Aliasing

When two local variables or fields reference the same object, we have aliasing.

Aliasing is the cause of many, many complex bugs.

Aliasing on immutable data is harmless. For example, Strings are deeply immutable. So are Integers.

```mutation.java
class Point{ Integer x; Integer y; }
class Person{ Point position; String name;
    Integer xy(){
        return this.position.x + this.position.y;
    }
    void addSurname(String surname){
        this.name = this.name + " " + surname;
    }
    void addX(Integer x0){
        this.position.x += x0;
    }
}

// is the Person is mutated by addX(x0)? - shallow mutability: no, deep mutability: yes
```

Updation vs Mutation.
field vs object.
an object is mutated if one of its fields are updated.

Post-It model.
(x = 23) + (x0 = 12) = 35.
23 + (x0 = 12) = (x = 35).
